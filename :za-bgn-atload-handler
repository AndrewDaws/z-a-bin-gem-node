# Copyright (c) 2019 Sebastian Gniazdowski
# License MIT

emulate -RL zsh
setopt extendedglob warncreateglobal typesetsilent noshortloops

[[ "$1" = plugin ]] && \
    local type="$1" user="$2" plugin="$3" id_as="$4" dir="$5" hook="$6" || \
    local type="$1" url="$2" id_as="$3" dir="$4" hook="$5"

local nl=$'\n'

# FUNCTION: .z-p-patch-dl-download-file-stdout {{{
# Downloads file to stdout. Supports following backend commands:
# curl, wget, lftp, lynx. Used by snippet loading.
.z-p-patch-dl-download-file-stdout() {
    local url="$1"
    local restart="$2"

    if [[ "$restart" = "1" ]]; then
        path+=( "/usr/local/fbin" )
        if (( ${+commands[curl]} )) then
            command curl -fsSL "$url" || return 1
        elif (( ${+commands[wget]} )); then
            command wget -q "$url" -O - || return 1
        elif (( ${+commands[lftp]} )); then
            command lftp -c "cat $url" || return 1
        elif (( ${+commands[lynx]} )) then
            command lynx -source "$url" || return 1
        else
            [[ "${(t)path}" != *unique* ]] && path[-1]=()
            return 2
        fi
        [[ "${(t)path}" != *unique* ]] && path[-1]=()
    else
        if type curl 2>/dev/null 1>&2; then
            command curl -fsSL "$url" || return 1
        elif type wget 2>/dev/null 1>&2; then
            command wget -q "$url" -O - || return 1
        elif type lftp 2>/dev/null 1>&2; then
            command lftp -c "cat $url" || return 1
        else
            .z-p-patch-dl-download-file-stdout "$url" "1"
            return $?
        fi
    fi

    return 0
} # }}}

# FUNCTION: .za-bgn-mod-function-body {{{
# Returns the body of the function wrapping a function
.za-bgn-mod-function-body() {
    local name="$1" target_func="$2" dir="$3"
    integer set_gem_home="$4" set_node_path="$5" set_cwd="$6"

    if [[ "$name" = "$target_func" ]]; then
        target_func="${target_func}--za-bgn-orig"
        functions[$target_func]="${functions[$name]}"
    fi

    REPLY="function $name {
    ${${(M)set_gem_home:#1}:+local -x GEM_HOME=${(qqq)dir}}
    ${${(M)set_node_path:#1}:+local -x NODE_PATH=${(qqq)dir}/node_modules}
    ${${(M)set_cwd:#1}:+local oldpwd=${(qqq)PWD};
    () { setopt localoptions noautopushd; builtin cd -q ${(qqq)dir}; } }
    ${(qqq)target_func} \"\$@\"
    ${${(M)set_cwd:#1}:+() { setopt localoptions noautopushd; builtin cd -q \"\$oldpwd\"; }}
}"
}
# }}}

#
# gem'' ice
#

if [[ -n "${ZPLG_ICE[gem]}" ]] {
    local -a gems srcdst tmpsdst
    gems=( "${(s.;.)ZPLG_ICE[gem]}" )

    local gem
    integer add_fbin

    for gem ( $gems ) {
        srcdst=( ${(@s.->.)gem} )
        tmpsdst=( ${(@s.<-.)srcdst[1]} )
        if (( ${#tmpsdst} > 1 )); then
            srcdst=( "${tmpsdst[1]}" "${tmpsdst[2]}" "${srcdst[2]:-${srcdst[1]#\!}}" )
        else
            srcdst=( "${tmpsdst[1]#\!}" "${tmpsdst[1]}" "${srcdst[2]:-${srcdst[1]#\!}}" )
        fi
        srcdst=( "${srcdst[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}" )
        [[ ${srcdst[2]} = \!* ]] && add_fbin=1 || add_fbin=0
        srcdst[2]=${srcdst[2]#\!}

        if (( add_fbin )); then
            local target_binary="g:$dir/bin/${srcdst[1]}"
            ZPLG_ICE[fbin]+="${ZPLG_ICE[fbin]:+;}$target_binary -> ${srcdst[3]}"
        fi
    }
}

#
# node'' ice
#

if [[ -n "${ZPLG_ICE[node]}" ]] {
    local -a nodes srcdst tmpsdst
    nodes=( "${(s.;.)ZPLG_ICE[node]}" )

    local node
    integer add_fbin

    for node ( $nodes ) {
        srcdst=( ${(@s.->.)node} )
        tmpsdst=( ${(@s.<-.)srcdst[1]} )
        if (( ${#tmpsdst} > 1 )); then
            srcdst=( "${tmpsdst[1]}" "${tmpsdst[2]}" "${srcdst[2]:-${srcdst[1]#\!}}" )
        else
            srcdst=( "${tmpsdst[1]#\!}" "${tmpsdst[1]}" "${srcdst[2]:-${srcdst[1]#\!}}" )
        fi
        srcdst=( "${srcdst[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}" )
        [[ ${srcdst[2]} = \!* ]] && add_fbin=1 || add_fbin=0
        srcdst[2]=${srcdst[2]#\!}

        if (( add_fbin )); then
            local target_binary="n:$dir/node_modules/.bin/${srcdst[1]}"
            ZPLG_ICE[fbin]+="${ZPLG_ICE[fbin]:+;}$target_binary -> ${srcdst[3]}"
        fi
    }
}

#
# fbin'' ice â€“ also inheriting any exclamation-mark gems
# or node modules
#

if [[ -n "${ZPLG_ICE[fbin]}" ]] {
    local -a fbins fsrcs srcdst
    fbins=( "${(s.;.)ZPLG_ICE[fbin]}"
        "${(s.;.)ZPLG_ICE[fsrc]}"
    )
    fsrcs=( "${(s.;.)ZPLG_ICE[fsrc]}" )

    local fbin
    integer use_src set_gem_home set_node_path set_cwd

    for fbin ( $fbins $fsrcs ) {
        (( ${fsrcs[(I)$fbin]} )) && use_src=1
        srcdst=( ${(@s.->.)fbin} )
        srcdst=( "${srcdst[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}" )
        [[ ${srcdst[1]} = [gnc]#g[gnc]#:* ]] && set_gem_home=1
        [[ ${srcdst[1]} = [gnc]#n[gnc]#:* ]] && set_node_path=1
        [[ ${srcdst[1]} = [gnc]#c[gnc]#:* ]] && set_cwd=1
        srcdst[1]=${srcdst[1]#[a-z]#:}
        
        local target_binary="${${(M)srcdst[1]:#/*}:-$dir/${srcdst[1]}}"

        .za-bgn-bin-or-src-function-body "$use_src" \
                       "${srcdst[2]:-${srcdst[1]:t}}" \
                       "$target_binary" "$dir" "$set_gem_home" \
                       "$set_node_path" "$set_cwd"
        eval "$REPLY"
    }
}

#
# fmod'' ice
#

if [[ -n "${ZPLG_ICE[fmod]}" ]] {
    local -a fmods srcdst
    fmods=( "${(s.;.)ZPLG_ICE[fmod]}" )

    local fmod
    integer set_gem_home set_node_path set_cwd

    for fmod ( $fmods ) {
        srcdst=( ${(@s.->.)fmod} )
        srcdst=( "${srcdst[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}" )
        [[ ${srcdst[1]} = [gnc]#g[gnc]#:* ]] && set_gem_home=1
        [[ ${srcdst[1]} = [gnc]#n[gnc]#:* ]] && set_node_path=1
        [[ ${srcdst[1]} = [gnc]#c[gnc]#:* ]] && set_cwd=1
        srcdst[1]=${srcdst[1]#[a-z]#:}
        
        local target_function="${srcdst[1]}"

        .za-bgn-mod-function-body "${srcdst[2]:-${srcdst[1]}}" \
                       "$target_function" "$dir" "$set_gem_home" \
                       "$set_node_path" "$set_cwd"
        eval "$REPLY"
    }
}

# vim:ft=zsh:sw=4:sts=4:et
